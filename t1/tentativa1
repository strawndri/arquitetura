; Trabalho 1 - Arquitetura de Computadores
; Feito por: Andrieli Luci Gonçalves

main:

    sub r0, r0       ; Zera R0
    sub r1, r1       ; Zera R1
    sub r2, r2       ; Zera R2
    sub r3, r3       ; Zera R3

    ; Inicializa vetor R com zeros (endereço 0x10)
    
    addi 0x01        ; r0 = 1
    add r1, r0       ; r1 = 1
    
    slr r1, r1       ; r1 = 2
    slr r1, r1       ; r1 = 4
    slr r1, r1       ; r1 = 8
    slr r1, r1       ; r1 = 16 (0x10)
    
    ; Configura contador (10 elementos)
    addi 0x0A        ; r0 = 10
    add r3, r0       ; r3 = 10

loop_R:
    brzr r3, end_R    ; Se r3 == 0, sai do loop
    
    st r0, r1         ; Armazena zero na posição atual de R
    
    ; Incrementa endereço (1 byte por elemento)
    addi 0x01         ; r0 = 1
    add r1, r0        ; r1 = r1 + 1
    
    ; Decrementa contador usando ADD com valor negativo (0xF = -1)
    addi 0x0F         ; r0 = -1 (em complemento de 2)
    add r3, r0        ; r3 = r3 - 1
    
    ji loop_R         ; Volta para o início do loop

end_R:
    ebreak


    ; =============================================
    ; Inicializa vetor A com zeros (endereço 0x20)
    ; =============================================
    
    ; Configura endereço base de A (0x20 = 32)
    addi 0x01        ; r0 = 1
    add r1, r0       ; r1 = 1
    
    slr r1, r1       ; r1 = 2
    slr r1, r1       ; r1 = 4
    slr r1, r1       ; r1 = 8
    slr r1, r1       ; r1 = 16 (0x10)
    slr r1, r1       ; r1 = 32 (0x20)
    
    ; Configura contador (10 elementos)
    addi 0x0A        ; r0 = 10
    add r3, r0       ; r3 = 10

loop_A:
    brzr r3, end_A    ; Se r3 == 0, sai do loop
    
    st r0, r1         ; Armazena zero na posição atual de A
    
    ; Incrementa endereço
    addi 0x01         ; r0 = 1
    add r1, r0        ; r1 = r1 + 1
    
    ; Decrementa contador
    addi 0x0F         ; r0 = -1
    add r3, r0        ; r3 = r3 - 1
    
    ji loop_A         ; Volta para o início do loop

end_A:

    ; =============================================
    ; Inicializa vetor B com zeros (endereço 0x30)
    ; =============================================
    
    ; Configura endereço base de B (0x30 = 48)
    ; Primeiro fazemos 0x20 (como anteriormente)
    addi 0x01        ; r0 = 1
    add r1, r0       ; r1 = 1
    
    slr r1, r1       ; r1 = 2
    slr r1, r1       ; r1 = 4
    slr r1, r1       ; r1 = 8
    slr r1, r1       ; r1 = 16 (0x10)
    slr r1, r1       ; r1 = 32 (0x20)
    
    ; Depois adicionamos 16 para chegar a 0x30 (48)
    addi 0x08        ; r0 = 8
    add r1, r0       ; r1 = 32 + 8 = 40 (0x28)
    addi 0x08        ; r0 = 8
    add r1, r0       ; r1 = 40 + 8 = 48 (0x30)
    
    ; Configura contador (10 elementos)
    addi 0x0A        ; r0 = 10
    add r3, r0       ; r3 = 10

loop_B:
    brzr r3, end_B    ; Se r3 == 0, sai do loop
    
    st r0, r1         ; Armazena zero na posição atual de B
    
    ; Incrementa endereço
    addi 0x01         ; r0 = 1
    add r1, r0        ; r1 = r1 + 1
    
    ; Decrementa contador
    addi 0x0F         ; r0 = -1
    add r3, r0        ; r3 = r3 - 1
    
    ji loop_B         ; Volta para o início do loop

end_B:

    ; =============================================
    ; Soma vetores A e B, armazena resultado em R
    ; =============================================
    
    ; Configura ponteiros
    ; r1 = endereço de A (0x20)
    addi 0x01        ; r0 = 1
    add r1, r0       ; r1 = 1
    
    slr r1, r1       ; r1 = 2
    slr r1, r1       ; r1 = 4
    slr r1, r1       ; r1 = 8
    slr r1, r1       ; r1 = 16 (0x10)
    slr r1, r1       ; r1 = 32 (0x20)
    
    ; r2 = endereço de B (0x30)
    add r2, r1       ; r2 = 0x20
    addi 0x08        ; r0 = 8
    add r2, r0       ; r2 = 0x28
    addi 0x08        ; r0 = 8
    add r2, r0       ; r2 = 0x30
    
    ; r3 = endereço de R (0x10)
    addi 0x01        ; r0 = 1
    add r3, r0       ; r3 = 1
    
    slr r3, r3       ; r3 = 2
    slr r3, r3       ; r3 = 4
    slr r3, r3       ; r3 = 8
    slr r3, r3       ; r3 = 16 (0x10)
    
    ; Configura contador (10 elementos)
    addi 0x0A        ; r0 = 10

loop_soma:
    brzr r0, end_soma  ; Se r0 == 0, sai do loop
    
    ; Carrega A[r1] em r2 temporariamente
    ld r2, r1         ; r2 = M[r1] (valor de A)
    
    ; Salva valor de A no registrador r3 temporariamente
    add r3, r2        ; r3 = valor de A
    
    ; Carrega valor de B
    ld r2, r2         ; r2 = M[r2] (valor de B)
    
    ; Soma A (em r3) + B (em r2)
    add r3, r2        ; r3 = A + B
    
    ; Armazena resultado em R
    st r3, r3         ; Armazena resultado em R (endereço em r3)
    
    ; Incrementa todos os ponteiros
    addi 0x01         ; r0 = 1
    add r1, r0        ; r1 = r1 + 1
    add r2, r0        ; r2 = r2 + 1
    add r3, r0        ; r3 = r3 + 1
    
    ; Decrementa contador
    addi 0x0F         ; r0 = -1
    add r0, r0        ; r0 = r0 - 1
    
    ji loop_soma      ; Volta para o início do loop

end_soma:

    ebreak
